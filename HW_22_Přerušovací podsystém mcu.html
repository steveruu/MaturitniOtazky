<!DOCTYPE html>                            <html>                                <head>                                    <meta charset="UTF-8">                                    <title>HW_22_Přerušovací podsystém mcu</title>                                    <link rel="stylesheet" href="./style/style.css">                                    <link rel="stylesheet" href="./style/kimbie.dark.css">                                    <meta name="viewport" content="width=device-width, initial-scale=1.0">                                                                    </head>                                <body><div class="markdown-container ltr"><div class="markdown-content"><h1 id="hw-22-p-eru-ovac-podsyst-m-mcu">HW 22 – Přerušovací podsystém mcu</h1>
<h2 id="p-eru-en-">Přerušení</h2>
<ul>
<li><p>Událost, na kterou chceme reagovat</p>
</li>
<li><p>Pomocí přerušovacího systému reagujeme na události</p>
</li>
<li><p>Události hardwarové a softwarové:</p>
</li>
<li><p>HW (častější):</p>
<ul>
<li><p>Změna hodnoty na I/O pinu – Externí přerušení</p>
</li>
<li><p>Přetečení čítače/časovače</p>
</li>
<li><p>Překročení hodnoty u komparátoru</p>
</li>
<li><p>Dokončení převodu u AD převodníku</p>
</li>
<li><p>Příjem nebo odeslání znaku u sériové komunikace</p>
</li>
</ul>
</li>
<li><p>SW:</p>
<ul>
<li><p>Neplatná adresa</p>
</li>
<li><p>Neplatný operační znak</p>
</li>
</ul>
</li>
<li><p>Reakce na událost:</p>
<ul>
<li><p>Přeruší se běžící program</p>
</li>
<li><p>Předá se řízení na nějakou speciální adresu</p>
</li>
<li><p>Na této adrese je přímo umístěný obslužný podprogram, nebo skok/adresa na skutečné umístění podprogramu (častější)</p>
</li>
</ul>
</li>
<li><p>U ATmega64 jsou přerušovací vektory (adresy vedoucí do paměti programu), kam se předává řízení</p>
<ul>
<li>Jsou na začátku PM odstupňované po dvou (0x0000, 0x0002, ...), aby se zde vešel nepodmíněný skok na skutečné místo podprogramu</li>
</ul>
</li>
<li><p>Tři skupiny přerušovacích systémů:</p>
<ol>
<li><p>Každá událost má vlastní interrupt vector (ATmega64)</p>
</li>
<li><p>Některé události mají vlastní IV, některé ho sdílí – režim kombinovaný/smíšený (Intel 8051)</p>
</li>
<li><p>Pouze jeden interrupt vector – vždy se skáče na jednu adresu, kde se musí softwarově vyhodnotit, co událost vyvolalo; pomalejší, ale lze definovat prioritu (Microchip PIC)</p>
</li>
</ol>
</li>
<li><p>Každý interrupt (každá událost, na kterou lze reagovat přerušením) se musí povolit – <em>Interrupt Mask Register</em></p>
<ul>
<li><p>Každá událost má vlastní povolovací bit, po resetu jsou zakázané</p>
</li>
<li><p>Také musí být povolen <em>Global Interrupt Enable</em> v registru status (bit č. 7, první zleva, písmeno I)</p>
</li>
<li><p>Tento bit se používá, pokud nechceme, aby obsluha přerušení byla přerušena jinou obsluhou přerušení</p>
</li>
</ul>
</li>
<li><p>Každý zdroj přerušení má také svůj interrupt flag (příznak) – <em>Interrupt Flag Register</em></p>
<ul>
<li><p>Nastavuje se na jedničku, pokud vzniklo dané přerušení</p>
</li>
<li><p>Softwarově lze vynulovat kdykoliv</p>
</li>
<li><p>Některé systémy umí hardwarově nulovat automaticky, jakmile se spustí obsluha</p>
</li>
<li><p>Pokud by se flag nevynuloval, volala by se obsluha přerušení stále dokola</p>
</li>
</ul>
</li>
<li><p>Problém při více aktivních událostech řeší priorita</p>
<ul>
<li><p>HW – Některé systémy obsahují registry, ve kterých lze každému interruptu nastavit prioritu, pořád ale lze nastavit u některých stejnou prioritu</p>
</li>
<li><p>U ATmega64 pořadí umístění vectorů v PM zároveň určuje jejich prioritu (nižší adresa = vyšší priorita)</p>
</li>
<li><p>U systémů s jedním interrupt vectorem se priorita definuje softwarově</p>
</li>
<li><p>U některých systémů může obsluha s vyšší prioritou přerušit obsluhu s nižší prioritou</p>
</li>
</ul>
</li>
<li><p>Kontext</p>
<ul>
<li><p>Obsluha přerušení může pracovat s nějakými registry, po jejím skončení by hlavní program mohl tyto registry také používat a nalézt v nich neočekávaná/nekorektní data</p>
</li>
<li><p>Korektní obsluha přerušení by měla zajistit, aby po jejím skončení obsah příznakových a pracovních registrů byl stejný, jako když byla obsluha vyvolána</p>
</li>
<li><p>Na začátku se uloží obsah registrů, jejichž obsah se bude modifikovat (např. na zásobník) a před návratem z přerušení se původní obsah (zvaný kontext) obnoví</p>
</li>
</ul>
</li>
<li><p>Zpracování</p>
<ul>
<li><p>Během každého instrukčního cyklu se vyhodnocuje, zdali nevzniklo nějaké přerušení</p>
</li>
<li><p>Pokud vzniklo a je povolené, tak se obsah následující instrukce uloží na zásobník a do PC (Program Counter) se nahraje příslušný interrupt vector</p>
</li>
<li><p>Tím se způsobí skok na adresu obsluhy přerušení a zakáže se <em>Global Interrupt Enable</em></p>
</li>
<li><p>Provede se obsluha přerušení</p>
</li>
<li><p>Součástí instrukce návrat z přerušení je povolení <em>Global Interrupt Enable</em>, ze zásobníku se vytáhne adresa, kam se máme vrátit a nahraje se do PC</p>
</li>
<li><p>Provede se minimálně jedna následující instrukce, během které se opět zkontrolují příznaky přerušení</p>
</li>
</ul>
</li>
<li><p>Instrukce zabírající více než jeden instrukční cyklus se nemohou přerušit v půlce, aktuální instrukce se vždy dokončí</p>
</li>
</ul>
</div></div></body>                            </html>